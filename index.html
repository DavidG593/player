<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hivestack VAST Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      color: #fff;
    }

    #container {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    video, img {
      max-width: 100vw;
      max-height: 100vh;
      width: 100%;
      height: 100%;
      object-fit: contain; /* preserve ratio, maximize inside screen */
      background: #000;
    }

    #status {
      position: fixed;
      left: 8px;
      bottom: 8px;
      padding: 4px 8px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 4px;
      color: #bbb;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- We'll dynamically switch between <video> and <img> -->
    <video id="adVideo" autoplay muted playsinline></video>
  </div>
  <div id="status">Initializing…</div>

  <script>
    (function () {
      "use strict";

      const VAST_URL = "https://uat.hivestack.com/nirvana/api/v1/units/08cfb0ac-1228-4725-a162-03cb7c6947f3/schedulevast";
      const FALLBACK_DURATION_MS = 8000; // 8 seconds if no Duration in VAST
      const PREFETCH_OFFSET_MS = 1000;   // prefetch next ad 1s before current ends

      const statusEl  = document.getElementById("status");
      const container = document.getElementById("container");

      let currentAd = null; // { mediaUrl, type: "video"|"image", durationMs, impressionUrls }
      let nextAd    = null;
      let playTimeout = null;
      let prefetchTimeout = null;

      function setStatus(msg) {
        if (statusEl) {
          statusEl.textContent = msg;
        }
      }

      function parseDuration(durationStr) {
        // Expect "HH:MM:SS" or "HH:MM:SS.mmm"
        if (!durationStr) return NaN;
        const parts = durationStr.trim().split(":");
        if (parts.length !== 3) return NaN;

        const [hStr, mStr, sPart] = parts;
        let sStr = sPart;
        let msStr = "0";

        if (sPart.includes(".")) {
          const tmp = sPart.split(".");
          sStr = tmp[0];
          msStr = tmp[1];
        }

        const hours = parseInt(hStr, 10) || 0;
        const mins  = parseInt(mStr, 10) || 0;
        const secs  = parseInt(sStr, 10) || 0;
        const ms    = parseInt(msStr.padEnd(3, "0"), 10) || 0;

        return ((hours * 3600 + mins * 60 + secs) * 1000) + ms;
      }

      function extractAdFromVast(xmlDoc) {
        // Grab Duration
        const durationNode = xmlDoc.querySelector("Linear > Duration");
        const durationMs = durationNode ? parseDuration(durationNode.textContent) : NaN;

        // Grab Impression URLs
        const impressionUrls = [];
        xmlDoc.querySelectorAll("Impression").forEach(node => {
          const url = node.textContent.trim();
          if (url) impressionUrls.push(url);
        });

        // Choose first media file (video preferred, but support images too)
        const mediaFiles = Array.from(xmlDoc.getElementsByTagName("MediaFile"));
        if (!mediaFiles.length) {
          throw new Error("No MediaFile elements in VAST");
        }

        let chosenMedia = null;
        for (const mf of mediaFiles) {
          const type = mf.getAttribute("type") || "";
          const delivery = (mf.getAttribute("delivery") || "").toLowerCase();
          const url = mf.textContent.trim();

          if (!url) continue;

          // Try to prefer progressive video/mp4
          if (type.startsWith("video/") && (delivery === "progressive" || delivery === "")) {
            chosenMedia = { url, kind: "video", type };
            break;
          }
        }

        // If no preferred video found, just pick the first with a URL
        if (!chosenMedia) {
          const mf = mediaFiles[0];
          const type = mf.getAttribute("type") || "";
          const url = mf.textContent.trim();
          const isImage = type.startsWith("image/");
          chosenMedia = {
            url,
            kind: isImage ? "image" : "video",
            type
          };
        }

        return {
          mediaUrl: chosenMedia.url,
          type: chosenMedia.kind,
          durationMs: Number.isFinite(durationMs) && durationMs > 0 ? durationMs : FALLBACK_DURATION_MS,
          impressionUrls
        };
      }

      async function fetchVastAd() {
        setStatus("Fetching VAST…");
        const response = await fetch(VAST_URL, { cache: "no-store" });
        if (!response.ok) {
          throw new Error("VAST request failed with status " + response.status);
        }
        const xmlText = await response.text();

        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");

        // Simple parse error check
        if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
          throw new Error("Error parsing VAST XML");
        }

        const ad = extractAdFromVast(xmlDoc);
        setStatus("VAST loaded");
        return ad;
      }

      function fireImpressions(urls) {
        if (!urls || !urls.length) return;
        urls.forEach(url => {
          try {
            // Using Image() ensures simple GET without worrying about CORS response
            const img = new Image();
            img.src = url;
          } catch (e) {
            console.error("Failed to fire impression:", e);
          }
        });
      }

      function clearTimers() {
        if (playTimeout) {
          clearTimeout(playTimeout);
          playTimeout = null;
        }
        if (prefetchTimeout) {
          clearTimeout(prefetchTimeout);
          prefetchTimeout = null;
        }
      }

      function createOrReuseMediaElement(type) {
        // Remove all media children, recreate appropriate element
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }

        if (type === "image") {
          const img = document.createElement("img");
          img.id = "adImage";
          container.appendChild(img);
          return img;
        } else {
          const video = document.createElement("video");
          video.id = "adVideo";
          video.autoplay = true;
          video.muted = true;       // helps with autoplay policies
          video.playsInline = true; // iOS inline playback
          video.controls = false;
          container.appendChild(video);
          return video;
        }
      }

      async function ensureNextAd() {
        if (nextAd) return;
        try {
          nextAd = await fetchVastAd();
        } catch (err) {
          console.error(err);
          setStatus("Error fetching next VAST: " + err.message);
        }
      }

      async function playNextAd() {
        clearTimers();

        // Rotate ads: next -> current
        if (!nextAd) {
          await ensureNextAd();
        }
        if (!nextAd) {
          setStatus("No ad available");
          // Try again in a few seconds
          playTimeout = setTimeout(playNextAd, 5000);
          return;
        }

        currentAd = nextAd;
        nextAd = null;

        const ad = currentAd;
        setStatus(`Playing ad (${ad.type}) for ${(ad.durationMs / 1000).toFixed(1)}s`);

        const el = createOrReuseMediaElement(ad.type);

        if (ad.type === "image") {
          el.src = ad.mediaUrl;
          fireImpressions(ad.impressionUrls);

          // Prefetch near end
          prefetchTimeout = setTimeout(() => {
            ensureNextAd();
          }, Math.max(ad.durationMs - PREFETCH_OFFSET_MS, 1000));

          playTimeout = setTimeout(() => {
            playNextAd();
          }, ad.durationMs);

        } else {
          // video
          el.src = ad.mediaUrl;

          // Some browsers need a play() call in a user gesture,
          // but muted autoplay should generally work.
          const startPlayback = () => {
            fireImpressions(ad.impressionUrls);

            // schedule prefetch before end
            prefetchTimeout = setTimeout(() => {
              ensureNextAd();
            }, Math.max(ad.durationMs - PREFETCH_OFFSET_MS, 1000));

            // schedule switch to next ad
            playTimeout = setTimeout(() => {
              playNextAd();
            }, ad.durationMs);
          };

          // Try immediate play, then hook events
          const playPromise = el.play();
          if (playPromise && typeof playPromise.then === "function") {
            playPromise
              .then(() => {
                startPlayback();
              })
              .catch(err => {
                console.warn("Autoplay might be blocked:", err);
                setStatus("Tap/click to start playback");
                // wait for user interaction
                const handler = () => {
                  el.play().then(() => {
                    startPlayback();
                  }).catch(e => {
                    console.error("Play failed after interaction:", e);
                  });
                  window.removeEventListener("click", handler);
                  window.removeEventListener("touchstart", handler);
                };
                window.addEventListener("click", handler);
                window.addEventListener("touchstart", handler);
              });
          } else {
            // Older browsers
            startPlayback();
          }
        }
      }

      async function init() {
        setStatus("Initializing player…");
        try {
          // Prefetch first ad
          await ensureNextAd();
          await playNextAd();
        } catch (err) {
          console.error(err);
          setStatus("Initialization error: " + err.message);
        }
      }

      init();
    })();
  </script>
</body>
</html>
